<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.29" />


<title>Working with NetCDF files in R - brycemecum.com</title>
<meta property="og:title" content="Working with NetCDF files in R - brycemecum.com">



  








<link href='//cdn.bootcss.com/highlight.js/9.11.0/styles/github.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="/css/fonts.css" media="all">
<link rel="stylesheet" href="/css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <ul class="nav-links">
    
    <li><a href="/">brycemecum.com</a></li>
    
    <li><a href="/cv">CV</a></li>
    
    <li><a href="/post/">Posts</a></li>
    
    <li><a href="https://github.com/amoeba">GitHub</a></li>
    
    <li><a href="https://twitter.com/brycem">Twitter</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">6 min read</span>
    

    <h1 class="article-title">Working with NetCDF files in R</h1>

    
    <span class="article-date">2014/02/18</span>
    

    <div class="article-content">
      <p><a href="http://en.wikipedia.org/wiki/NetCDF">NetCDF</a> is an open file format commonly used to store oceanographic (and other) data such as sea surface temperature (SST), sea level pressure (SLP), and much more. I recently needed to work with SST data from the <a href="http://www.esrl.noaa.gov/psd/data/gridded/data.ncep.reanalysis.surface.html">NCEP Reanalysis</a> and found that I didn’t know how to work with NetCDF files. This post should serve as a short introduction working with NetCDF files using the R package <code>ncdf</code>.</p>
<div id="step-1-acquire-the-netcdf-library" class="section level2">
<h2>Step 1: Acquire the NetCDF library</h2>
<p>Before we can open a NetCDF file in R, we need to install the NetCDF library on our system. I’m using a Mac running OS 10.9 and I use <a href="http://brew.sh/"><code>homebrew</code></a> as my package manager.</p>
<p>If you’re using <code>homebrew</code>, install the <code>netcdf</code> library with:</p>
<pre><code>brew install netcdf</code></pre>
<p>If you’re on Windows, you can find pre-built binaries at the developer’s <a href="http://www.unidata.ucar.edu/downloads/netcdf/index.jsp">download page</a>. For other systems, consult the <a href="http://www.unidata.ucar.edu/software/netcdf/docs/getting.html">documentation</a>.</p>
</div>
<div id="step-2-install-and-load-the-ncdf-package-in-r" class="section level2">
<h2>Step 2: Install and load the <code>ncdf</code> package in R</h2>
<pre class="r"><code>install.packages(&quot;ncdf4&quot;)</code></pre>
<p>And load it:</p>
<pre class="r"><code>library(ncdf4)</code></pre>
</div>
<div id="step-3-load-your-netcdf-file" class="section level2">
<h2>Step 3: Load your NetCDF file</h2>
<p>For this tutorial, I’ll be working with the <a href="http://www.esrl.noaa.gov/psd/data/gridded/data.noaa.oisst.v2.html">NOAA Optimum Interpolation (OI) Sea Surface Temperature (SST) V2</a> data series of monthly means from December 1981 – current. These data are produced on a 1° grid for the entire globe.</p>
<pre class="r"><code>sst_url &lt;- &quot;ftp://ftp.cdc.noaa.gov/Datasets/noaa.oisst.v2/sst.mnmean.nc&quot;
sst_path &lt;- tempfile()
download.file(sst_url, sst_path) # 53.0 MB
cdf &lt;- nc_open(sst_path)</code></pre>
<p>I am interested in the following variables: latitude, longitude, time, and SST:</p>
<pre class="r"><code>lat &lt;- ncdf4::ncvar_get(cdf, varid=&quot;lat&quot;)
lon &lt;- ncdf4::ncvar_get(cdf, varid=&quot;lon&quot;)
time &lt;- ncdf4::ncvar_get(cdf, varid=&quot;time&quot;)
sst &lt;- ncdf4::ncvar_get(cdf, varid=&quot;sst&quot;)</code></pre>
<p>The <code>lat</code> and <code>lon</code> variables are just vectors containing the range of latitudes (89.5S to 89.5N) and longitudes (0.5°E to 359.5°E, starting from the prime meridian).</p>
<p>The <code>time</code> variable is a little more complex. Let’s take a look:</p>
<pre class="r"><code>head(time)</code></pre>
<pre><code>## [1] 66443 66474 66505 66533 66564 66594</code></pre>
<p>Those don’t look like times at all. If you’re used to working with dates and times on computers, you may already be way ahead of me. If, however, if you are not, I’ll explain. Dates and times are usually stored by computers as a number of time units since we started counting time. The time units may be milliseconds, seconds, or even months – whatever suits the purpose. Computers commonly store dates and times as the number of seconds since January 1, 1970 (See <a href="http://en.wikipedia.org/wiki/Unix_time">UNIX time</a>). In the case of our data, time is being counted as <strong>days</strong> since January 1, 1800. This is a little weird but it makes sense for our data. If you’re using a different NetCDF file than me, you’ll want to consult the documentation that goes along with the data to figure out how they’re counting time.</p>
<p>Now that we know how <code>time</code> is being stored, we can make it human-readable:</p>
<pre class="r"><code>time_d &lt;- as.Date(time, format=&quot;%j&quot;, origin=as.Date(&quot;1800-01-01&quot;))</code></pre>
<pre><code>## Warning in strptime(xx, f &lt;- &quot;%Y-%m-%d&quot;, tz = &quot;GMT&quot;): unknown timezone
## &#39;default/America/Juneau&#39;</code></pre>
<pre class="r"><code>time_years &lt;- format(time_d, &quot;%Y&quot;)
time_months &lt;- format(time_d, &quot;%m&quot;)
time_year_months &lt;- format(time_d, &quot;%Y-%m&quot;)</code></pre>
<p>Here, I set the origin to January 1, 1800 and then convert the original variable <code>time</code> into a vector of R <code>Date</code> objects, passing the parameters <code>format=&quot;%j&quot;</code> and <code>origin=as.Date(&quot;1800-01-01&quot;)</code>. The <code>time</code> variable is now much more easier to understand:</p>
<pre class="r"><code>head(time_d)</code></pre>
<pre><code>## [1] &quot;1981-12-01&quot; &quot;1982-01-01&quot; &quot;1982-02-01&quot; &quot;1982-03-01&quot; &quot;1982-04-01&quot;
## [6] &quot;1982-05-01&quot;</code></pre>
<p>The other variables I created, <code>time_years</code>, <code>time_months</code>, <code>time_year_months</code> are for added utility. I can now reference SST data for just a set of years</p>
<pre class="r"><code>time_years %in% c(&quot;1990&quot;, &quot;1991&quot;)</code></pre>
<p>or all SST values from June</p>
<pre class="r"><code>time_months %in% c(&quot;06&quot;)</code></pre>
<p>Our last, but most important variable is SST.</p>
<pre class="r"><code>dim(sst)</code></pre>
<pre><code>## [1] 360 180 429</code></pre>
<p><code>sst</code> is three dimensional, and is indexed by longitude, latitude, and time (respectively). To extract a single SST value from it, we’ll need to specify an index or range of indices for all three dimensions:</p>
<pre class="r"><code>sst[lon==220.5, lat==50.5, time_d==as.Date(&quot;1990-06-01&quot;)]</code></pre>
<pre><code>## [1] 10.91</code></pre>
<p>We can use our utility variables to, for example, extract all the observations for June from this same grid cell:</p>
<pre class="r"><code>sst[lon==220.5, lat==50.5, time_months==&quot;06&quot;]</code></pre>
<pre><code>##  [1]  9.27 10.25  9.68  8.81  9.75  8.96  8.82  9.79 10.91 10.04  9.55
## [12] 11.01 10.55  9.46  9.39 10.21 10.00  7.94  9.39  8.78 10.08 10.05
## [23] 10.56 10.67  9.78  8.65  8.33 10.04  8.88  9.11  8.21 10.19 11.51
## [34] 12.05 10.27  9.76</code></pre>
<p>Depending on your goals, this may be as far as you need to get. But maybe you want to display these data visually. Let’s plot the SSTs for a range of grid cells onto a map.</p>
</div>
<div id="step-4-convert-the-sst-data-to-a-data.frame" class="section level2">
<h2>Step 4: Convert the SST data to a <code>data.frame</code></h2>
<p>Our NetCDF file has a lot of observations:</p>
<pre class="r"><code>prod(dim(sst))</code></pre>
<pre><code>## [1] 27799200</code></pre>
<p>To reduce the amount of computation, let’s subset the data to a range of latitudes and longitudes and also focus in on a particular month in the data set so we can plot this in two dimensions:</p>
<pre class="r"><code>lat_range &lt;- seq(55.5, 60.5)
lon_range &lt;- seq(190.5, 195.5)

lat_indices &lt;- lat %in% lat_range
lon_indices &lt;- lon %in% lon_range
time_indices &lt;- time_year_months==&quot;1990-06&quot; # June of 1990</code></pre>
<p>Notice how I constructed the <code>_indices</code> variables. They are vectors of the same length as their corresponding variable but they contain TRUEs and FALSEs where the corresponding variable is equal to the desired ranges. This allows instant subsetting:</p>
<pre class="r"><code>sst[lon_indices, lat_indices, time_indices]</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6]
## [1,] 4.20 4.12 4.63 5.47 6.19 6.63
## [2,] 4.39 4.05 4.40 5.18 5.99 6.64
## [3,] 4.71 4.04 4.11 4.73 5.58 6.55
## [4,] 5.21 4.39 4.32 4.82 5.63 6.61
## [5,] 5.57 4.91 4.80 5.17 5.87 6.70
## [6,] 5.53 5.36 5.29 5.55 6.12 6.81</code></pre>
<p>Which gives us the SST values for the 5x5 grid for June of 1990. To save them in a more convenient format, we’ll convert it to a <code>data.frame</code>.</p>
<pre class="r"><code>cdf_df &lt;- expand.grid(lat_range, lon_range)
names(cdf_df) &lt;- c(&quot;lat&quot;, &quot;lon&quot;)
cdf_df$sst &lt;- NA
head(cdf_df)</code></pre>
<pre><code>##    lat   lon sst
## 1 55.5 190.5  NA
## 2 56.5 190.5  NA
## 3 57.5 190.5  NA
## 4 58.5 190.5  NA
## 5 59.5 190.5  NA
## 6 60.5 190.5  NA</code></pre>
<p>Now each row of <code>cdf_df</code> will correspond to one SST value, one row for every grid cell combination (25 in total). Let’s populate it with SST values:</p>
<pre class="r"><code>for(i in 1:nrow(cdf_df))
{
  lat_ind &lt;- which(lat == cdf_df[i,&quot;lat&quot;])
  lon_ind &lt;- which(lon == cdf_df[i,&quot;lon&quot;])
  
  cdf_df[i,&quot;sst&quot;] &lt;- sst[lon_ind, lat_ind, time_indices]
}

head(cdf_df)</code></pre>
<pre><code>##    lat   lon  sst
## 1 55.5 190.5 6.63
## 2 56.5 190.5 6.19
## 3 57.5 190.5 5.47
## 4 58.5 190.5 4.63
## 5 59.5 190.5 4.12
## 6 60.5 190.5 4.20</code></pre>
<p>Looks good! Let’s make a map to display these data on. Luckily, this is pretty straightforward in R using the <code>maps</code> and <code>mapdata</code> packages.</p>
<pre class="r"><code>library(maps)
library(mapdata)
map(&#39;world2Hires&#39;, xlim=range(lon_range) + c(-10, 10), ylim=range(lat_range) + c(-5, 5))
box()
points(cdf_df$lon, cdf_df$lat)</code></pre>
<p><img src="/post/2014-02-18-working-with-netcdf-files-in-r_files/figure-html/firstmap-1.png" width="672" /></p>
<p>The above map is a good start. I’ve used the <code>world2Hires</code> map from <code>mapdata</code> which lets me create a map centered on the Eastern Bering Sea. I’ve specific the x- and y-limits to show just the area where we have SST values. Let’s change the points to rectangles and make the background color of the rectangles correlate with the corresponding SST value for that grid.</p>
<p>We’ll first make the color scale:</p>
<pre class="r"><code>ncolors &lt;- 5
cols &lt;- cut(cdf_df$sst, ncolors)
palette &lt;- colorRampPalette((c(&quot;blue&quot;, &quot;red&quot;)))(ncolors)</code></pre>
<p>To plot rectangles instead of points, we can use the rect() function instead of <code>points()</code>. <code>rect()</code> draws rectangles on the graphics device and needs the user to specify the coordinates of each corner (xleft, ybottom, xright, ytop).</p>
<pre class="r"><code>map(&#39;world2Hires&#39;, xlim=range(lon_range) + c(-10, 10), ylim=range(lat_range) + c(-5, 5))
box()

grid_hw &lt;- 0.5 # Grid half width
rect(cdf_df$lon - grid_hw, cdf_df$lat - grid_hw, cdf_df$lon + grid_hw, cdf_df$lat + grid_hw, col=palette[cols])

map.axes()
title(main=&quot;June SST Values&quot;, xlab=&quot;Longitude&quot;, ylab=&quot;Lattitude&quot;)
legend(&quot;topright&quot;, legend=levels(cols), fill=palette)</code></pre>
<p><img src="/post/2014-02-18-working-with-netcdf-files-in-r_files/figure-html/finalmap-1.png" width="672" /></p>
<p>Looks great! Hopefully this post was a useful introduction to working with and displaying NetCDF data.</p>
</div>

    </div>
  </article>

  


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="/index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/images/hugo-logo.png" width="22" height="22"></a>
          </li>
          <li>
            <a href="https://creativecommons.org/publicdomain/zero/1.0/">All content CC-0 1.0</a></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdn.bootcss.com/highlight.js/9.11.0/highlight.min.js"></script>



<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/yaml.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="/js/math-code.js"></script>
<script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
  </body>
</html>

